# 1.1.3 Выполнение комбинаций операторов
Одна из наших целей в этой главе: выделить проблемы, связанные с процедурным мышлением. В качестве примера рассмотрим, что при выполнении комбинаций операторов интерпретатор сам следует процедуре. Чтобы выполнить комбинацию операторов, сделайте следующее:
> 1. Выполните выражения операндов комбинации.
> 2. Примените функцию, обозначенную оператором, к аргументам, которые являются значениями операндов.

Даже это простое правило иллюстрирует некоторые важные моменты, касающиеся процессов в целом. Во-первых, обратите внимание, что первый шаг диктует, что для завершения процесса выполнения комбинации мы должны сначала завершить процесс исполнения для каждого операнда комбинации. Таким образом, правило выполнения носит рекурсивный характер; то есть он включает в себя в качестве одного из своих шагов необходимость активировать само правило.

Обратите внимание, как лаконично идея рекурсии может быть использована для выражения того, что в случае глубоко вложенной комбинации в противном случае могло бы рассматриваться как довольно сложный процесс. Например, оценивая

`(2 + 4 * 6) * (3 + 12);`

требует, чтобы правило выполнения применялось к четырем различным комбинациям. Мы можем получить картину этого процесса, представив комбинацию в виде дерева, как показано на рисунке 1.1. Каждая комбинация представлена узлом с ветвями, соответствующими оператору и операндам комбинации, вытекающей из него. Конечные узлы (то есть узлы, от которых не исходят ветви) представляют собой операторы или числа. Рассматривая оценку в терминах дерева, мы можем представить себе, что значения операндов просачиваются вверх, начиная с конечных узлов и затем объединяясь на все более высоких уровнях. В общем, мы увидим, что рекурсия — очень мощный метод работы с иерархическими древовидными объектами. Фактически, восходящая форма правила выполнения с просачиванием значений является примером общего вида процесса, известного как накопление дерева (tree accumulation).

![1.1](https://source-academy.github.io/sicp/img_javascript/ch1-Z-G-1.svg)
Рисунок 1.1 Древовидное представление, показывающее значение каждого подвыражения.

Затем обратите внимание, что повторное применение первого шага приводит нас к точке, где нам нужно выполнять не комбинации, а примитивные выражения, такие как числа или имена. Мы позаботимся о примитивных случаях, указав, что

> - значения цифр - это числа и
> - значения имен - это объекты, связанные с этими именами в среде.

Ключевой момент, на который следует обратить внимание, - это роль среды в определении значения имен в выражениях. В интерактивном языке, таком как JavaScript, бессмысленно говорить о значении выражения, такого как *x + 1*, без указания какой-либо информации о среде, которая могла бы дать значение для имени x. Как мы увидим в главе 3, общее представление о среде как об обеспечении контекста, в котором происходит выполнение, будет играть важную роль в нашем понимании выполнения программы.

Обратите внимание, что приведенное выше правило выполнения не обрабатывает объявления. Например, вычисление const **x = 3**; не применяет оператор равенства = к двум аргументам, один из которых является значением имени **x**, а другой - **3**, поскольку цель объявления состоит именно в том, чтобы связать x со значением. (То есть **const x = 3;** не является комбинацией.)

Буквы в const выделены жирным шрифтом, чтобы указать, что это ключевое слово в JavaScript. Ключевые слова несут определенное значение и поэтому не могут использоваться в качестве имен. Ключевое слово или комбинация ключевых слов в инструкции инструктируют интерпретатор JavaScript обрабатывать инструкцию особым образом. Каждая такая синтаксическая форма имеет свое собственное правило выполнения. Различные типы операторов и выражений (каждое со своим правилом выполнения) составляют синтаксис языка программирования.